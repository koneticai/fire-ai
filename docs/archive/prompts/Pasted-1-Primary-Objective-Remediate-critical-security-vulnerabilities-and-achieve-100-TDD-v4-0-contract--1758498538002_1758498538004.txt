1. Primary Objective
Remediate critical security vulnerabilities and achieve 100% TDD v4.0 contract compliance by fixing hardcoded secrets, completing pagination logic, and ensuring all 8 contract tests pass.

2. CRITICAL SECURITY REMEDIATION

Step 2.1: Remove ALL Hardcoded Secrets
First, check for any hardcoded secrets in your codebase:
```bash
# Search for hardcoded secrets
grep -r "JWT_SECRET_KEY\|DATABASE_URL\|password" --include="*.py" --include="*.yaml" --include="*.toml" .
Step 2.2: Configure Replit Secrets
In Replit, use the Secrets panel (padlock icon in sidebar) to add:

JWT_SECRET_KEY (generate: openssl rand -hex 32)
INTERNAL_JWT_SECRET_KEY (generate: openssl rand -hex 32)
DATABASE_URL (use Replit's PostgreSQL connection string)

Step 2.3: Update Environment Loading
Create src/app/config.py if not exists:
pythonimport os
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    jwt_secret_key: str = os.getenv("JWT_SECRET_KEY", "")
    internal_jwt_secret_key: str = os.getenv("INTERNAL_JWT_SECRET_KEY", "")
    database_url: str = os.getenv("DATABASE_URL", "")
    algorithm: str = "HS256"
    
    class Config:
        env_file = ".env"
        
    def validate_secrets(self):
        """Fail fast if secrets are not configured"""
        if not self.jwt_secret_key:
            raise ValueError("JWT_SECRET_KEY not configured in secrets")
        if not self.internal_jwt_secret_key:
            raise ValueError("INTERNAL_JWT_SECRET_KEY not configured in secrets")
        if not self.database_url:
            raise ValueError("DATABASE_URL not configured in secrets")

settings = Settings()
settings.validate_secrets()

FIX PAGINATION LOGIC

Step 3.1: Fix Test Sessions Router
Replace src/app/routers/test_sessions.py with corrected pagination:
pythonimport base64
import json
import uuid
from datetime import datetime
from typing import List, Optional

from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy import and_, select
from sqlalchemy.ext.asyncio import AsyncSession

from ..config import settings
from ..database.core import get_db
from ..dependencies import get_current_active_user
from ..models.test_sessions import TestSession
from ..schemas.token import TokenData

router = APIRouter(prefix="/v1/tests/sessions", tags=["test_sessions"])

@router.get("/")
async def list_test_sessions(
    limit: int = Query(20, ge=1, le=100),
    cursor: Optional[str] = None,
    status: Optional[List[str]] = Query(None),
    date_from: Optional[str] = None,
    date_to: Optional[str] = None,
    db: AsyncSession = Depends(get_db),
    current_user: TokenData = Depends(get_current_active_user)
):
    """List test sessions with proper cursor pagination"""
    query = select(TestSession)
    conditions = []
    
    # Decode cursor
    if cursor:
        try:
            cursor_data = json.loads(base64.b64decode(cursor))
            last_id = cursor_data.get("last_evaluated_id")
            if last_id:
                conditions.append(TestSession.id > uuid.UUID(last_id))
        except Exception:
            raise HTTPException(status_code=400, detail="Invalid cursor")
    
    # Apply filters
    if status:
        conditions.append(TestSession.status.in_(status))
    if date_from:
        conditions.append(TestSession.created_at >= datetime.fromisoformat(date_from))
    if date_to:
        conditions.append(TestSession.created_at <= datetime.fromisoformat(date_to))
    
    if conditions:
        query = query.where(and_(*conditions))
    
    # Order by ID for consistent pagination
    query = query.order_by(TestSession.id).limit(limit + 1)
    
    result = await db.execute(query)
    sessions = result.scalars().all()
    
    # Determine if there's a next page
    has_next_page = len(sessions) > limit
    if has_next_page:
        # Remove the extra item used for detection
        sessions = sessions[:limit]
    
    # Generate next cursor only if there's a next page
    next_cursor = None
    if has_next_page and sessions:
        last_session = sessions[-1]
        cursor_data = {
            "last_evaluated_id": str(last_session.id),
            "vector_clock": getattr(last_session, 'vector_clock', {})
        }
        next_cursor = base64.b64encode(json.dumps(cursor_data).encode()).decode()
    
    return {
        "data": [
            {
                "session_id": str(s.id),
                "building_id": str(s.building_id) if s.building_id else None,
                "status": s.status,
                "created_at": s.created_at.isoformat() if s.created_at else None
            } for s in sessions
        ],
        "next_cursor": next_cursor  # Will be None on last page
    }

@router.post("/{session_id}/results")
async def submit_crdt_results(
    session_id: str,
    changes: List[dict],
    idempotency_key: str = Query(...),
    db: AsyncSession = Depends(get_db),
    current_user: TokenData = Depends(get_current_active_user)
):
    """Submit CRDT results with idempotency"""
    import httpx
    from ..proxy import create_internal_token
    
    # Verify session exists
    result = await db.execute(
        select(TestSession).where(TestSession.id == uuid.UUID(session_id))
    )
    session = result.scalar_one_or_none()
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    
    # Proxy to Go service
    internal_token = create_internal_token()
    headers = {
        "X-Internal-Authorization": f"Bearer {internal_token}",
        "X-User-ID": str(current_user.user_id),
        "Idempotency-Key": idempotency_key
    }
    
    async with httpx.AsyncClient() as client:
        try:
            response = await client.post(
                f"http://localhost:9090/v1/tests/sessions/{session_id}/results",
                json={"changes": changes, "idempotency_key": idempotency_key},
                headers=headers,
                timeout=10.0
            )
            response.raise_for_status()
            return response.json()
        except httpx.TimeoutException:
            raise HTTPException(status_code=504, detail="Go service timeout")
        except httpx.HTTPStatusError as e:
            raise HTTPException(status_code=e.response.status_code, detail=str(e))

COMPLETE PROXY IMPLEMENTATION

Step 4.1: Update src/app/proxy.py
pythonimport os
from datetime import datetime, timedelta
from jose import jwt
from ..config import settings

def create_internal_token() -> str:
    """Create short-lived JWT for internal service communication"""
    expire = datetime.utcnow() + timedelta(minutes=5)
    payload = {
        "exp": expire,
        "iat": datetime.utcnow(),
        "aud": "firemode-go-service",
        "iss": "firemode-python-service",
        "type": "internal"
    }
    
    return jwt.encode(
        payload,
        settings.internal_jwt_secret_key,
        algorithm=settings.algorithm
    )

UPDATE DEPENDENCIES

Step 5.1: Fix src/app/dependencies.py
pythonfrom fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer
from jose import JWTError, jwt
from sqlalchemy.ext.asyncio import AsyncSession

from .config import settings
from .database.core import get_db
from .models.rtl import TokenRevocationList
from .schemas.token import TokenData

security = HTTPBearer()

async def get_current_active_user(
    token: HTTPBearer = Depends(security),
    db: AsyncSession = Depends(get_db)
) -> TokenData:
    """Validate JWT and check revocation list"""
    try:
        payload = jwt.decode(
            token.credentials,
            settings.jwt_secret_key,
            algorithms=[settings.algorithm]
        )
        
        # Check RTL
        jti = payload.get("jti")
        if jti:
            from sqlalchemy import select
            result = await db.execute(
                select(TokenRevocationList).where(
                    TokenRevocationList.jti == jti
                )
            )
            if result.scalar_one_or_none():
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Token has been revoked"
                )
        
        return TokenData(**payload)
        
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token"
        )

COMPLETE CONTRACT TEST SUITE

Step 6.1: Create tests/test_phase2_final.py
pythonimport pytest
import base64
import json
import uuid
from httpx import AsyncClient
from src.app.main import app

@pytest.mark.asyncio
async def test_standardized_error_format():
    """Test FIRE-XXX error format compliance"""
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.get("/v1/nonexistent")
        assert response.status_code == 404
        error = response.json()
        assert "transaction_id" in error
        assert error["error_code"] == "FIRE-404"
        assert error["retryable"] is True

@pytest.mark.asyncio
async def test_pagination_last_page_null_cursor():
    """Test that last page returns null cursor"""
    async with AsyncClient(app=app, base_url="http://test") as client:
        # Mock auth header
        headers = {"Authorization": "Bearer test-token"}
        
        # Request with high limit to get all items
        response = await client.get(
            "/v1/tests/sessions?limit=100",
            headers=headers
        )
        
        if response.status_code == 200:
            data = response.json()
            assert "data" in data
            assert "next_cursor" in data
            # When all items fit in one page, cursor should be null
            if len(data["data"]) < 100:
                assert data["next_cursor"] is None

@pytest.mark.asyncio
async def test_pagination_cursor_format():
    """Test cursor format compliance"""
    # Create test cursor
    cursor_data = {
        "last_evaluated_id": str(uuid.uuid4()),
        "vector_clock": {"node1": 1}
    }
    cursor = base64.b64encode(json.dumps(cursor_data).encode()).decode()
    
    # Verify it can be decoded
    decoded = json.loads(base64.b64decode(cursor))
    assert "last_evaluated_id" in decoded
    assert "vector_clock" in decoded

@pytest.mark.asyncio
async def test_health_endpoint():
    """Test health endpoint availability"""
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.get("/health/ready")
        assert response.status_code == 200

@pytest.mark.asyncio
async def test_no_hardcoded_secrets():
    """Verify no hardcoded secrets in config"""
    from src.app.config import settings
    assert settings.jwt_secret_key != ""
    assert "your-secret-key" not in settings.jwt_secret_key
    assert "default" not in settings.internal_jwt_secret_key

RUN MIGRATIONS

Step 7.1: Execute in shell
bashpoetry run alembic revision --autogenerate -m "Phase 2 final schema"
poetry run alembic upgrade head

FINAL VALIDATION

Step 8.1: Run complete test suite
bash# Run all tests
poetry run pytest tests/test_phase2_final.py -v

# Verify no hardcoded secrets
grep -r "password\|secret" --include="*.py" src/ | grep -v "os.getenv"