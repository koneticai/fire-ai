#!/usr/bin/env node
/**
 * TypeScript Type Generator from JSON Schema v7
 * Part of FM-ENH-001: Schema Registry Implementation
 * 
 * Reads JSON Schemas from services/api/schemas/ and generates
 * TypeScript interface definitions in packages/schema-types/dist/
 * 
 * MPKF-Ref: TDD-v4.0-Section-11.5,MPKF-v3.1
 */

import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Canonical paths
const REPO_ROOT = path.resolve(__dirname, '../..');
const SCHEMA_ROOT = path.join(REPO_ROOT, 'services/api/schemas');
const OUTPUT_DIR = path.join(REPO_ROOT, 'packages/schema-types/dist');

// Type mapping from JSON Schema to TypeScript
const TYPE_MAP = {
  string: 'string',
  number: 'number',
  integer: 'number',
  boolean: 'boolean',
  array: 'Array',
  object: 'Record<string, any>',
};

/**
 * Convert JSON Schema property to TypeScript type
 */
function schemaTypeToTS(prop, propName = '') {
  if (!prop) return 'any';

  // Handle $ref references
  if (prop.$ref) {
    const refParts = prop.$ref.split('/');
    const refName = refParts[refParts.length - 1];
    return toPascalCase(refName);
  }

  // Handle enum
  if (prop.enum) {
    return prop.enum.map(v => `"${v}"`).join(' | ');
  }

  // Handle array
  if (prop.type === 'array') {
    const itemType = prop.items ? schemaTypeToTS(prop.items) : 'any';
    return `${itemType}[]`;
  }

  // Handle object with properties
  if (prop.type === 'object' && prop.properties) {
    return generateInterface(prop, propName, true);
  }

  // Basic type mapping
  return TYPE_MAP[prop.type] || 'any';
}

/**
 * Generate TypeScript interface from schema
 */
function generateInterface(schema, interfaceName, inline = false) {
  if (!schema.properties) {
    return TYPE_MAP[schema.type] || 'any';
  }

  const required = schema.required || [];
  const properties = Object.entries(schema.properties)
    .map(([propName, propSchema]) => {
      const isRequired = required.includes(propName);
      const propType = schemaTypeToTS(propSchema, propName);
      const optional = isRequired ? '' : '?';
      const comment = propSchema.description ? `  /** ${propSchema.description} */\n` : '';
      return `${comment}  ${propName}${optional}: ${propType};`;
    })
    .join('\n');

  if (inline) {
    return `{\n${properties}\n}`;
  }

  return `export interface ${interfaceName} {\n${properties}\n}`;
}

/**
 * Convert kebab-case or snake_case to PascalCase
 */
function toPascalCase(str) {
  return str
    .replace(/[-_](.)/g, (_, char) => char.toUpperCase())
    .replace(/^(.)/, (_, char) => char.toUpperCase())
    .replace(/\.json$/, '');
}

/**
 * Generate interface name from file path
 */
function getInterfaceName(filePath, schemaType) {
  const fileName = path.basename(filePath, '.json');
  const baseName = fileName.replace(/_v\d+$/, ''); // Remove version suffix
  const prefix = schemaType === 'requests' ? 'Request' : 
                 schemaType === 'responses' ? 'Response' : '';
  return toPascalCase(baseName) + prefix;
}

/**
 * Process all schema files in a directory
 */
async function processSchemaDir(schemaDir, schemaType) {
  const dirPath = path.join(SCHEMA_ROOT, schemaDir);
  
  try {
    const files = await fs.readdir(dirPath);
    const interfaces = [];

    for (const file of files) {
      if (!file.endsWith('.json')) continue;

      const filePath = path.join(dirPath, file);
      const schemaContent = await fs.readFile(filePath, 'utf-8');
      const schema = JSON.parse(schemaContent);

      const interfaceName = getInterfaceName(file, schemaType);
      const interfaceCode = generateInterface(schema, interfaceName);

      interfaces.push({
        name: interfaceName,
        code: interfaceCode,
        file: file,
        description: schema.description || `${interfaceName} type definition`,
      });
    }

    return interfaces;
  } catch (error) {
    if (error.code === 'ENOENT') {
      console.warn(`‚ö†Ô∏è  Directory not found: ${dirPath}`);
      return [];
    }
    throw error;
  }
}

/**
 * Generate the main index.d.ts file
 */
async function generateTypes() {
  console.log('üîÑ Generating TypeScript types from JSON Schemas...\n');

  // Ensure output directory exists
  await fs.mkdir(OUTPUT_DIR, { recursive: true });

  // Process all schema directories
  const requests = await processSchemaDir('requests', 'requests');
  const responses = await processSchemaDir('responses', 'responses');
  const common = await processSchemaDir('common', 'common');

  // Generate header
  const header = `/**
 * Auto-generated TypeScript types from JSON Schema v7
 * DO NOT EDIT THIS FILE MANUALLY
 * 
 * Generated: ${new Date().toISOString()}
 * Source: FM-ENH-001 Schema Registry
 * MPKF-Ref: TDD-v4.0-Section-11.5,MPKF-v3.1
 * 
 * To regenerate: npm run generate:types
 */

`;

  // Combine all interfaces
  const allInterfaces = [...common, ...requests, ...responses];
  
  const typeDefinitions = allInterfaces
    .map(({ code, file, description }) => `// Source: ${file}\n// ${description}\n${code}`)
    .join('\n\n');

  // Export summary
  const exportList = allInterfaces
    .map(({ name }) => `  ${name},`)
    .join('\n');

  const footer = `\n\n// Export all types\nexport type {\n${exportList}\n};\n`;

  // Write output file
  const outputPath = path.join(OUTPUT_DIR, 'index.d.ts');
  await fs.writeFile(outputPath, header + typeDefinitions + footer, 'utf-8');

  console.log('‚úÖ Type generation complete!\n');
  console.log(`üìù Generated ${allInterfaces.length} interfaces:`);
  allInterfaces.forEach(({ name, file }) => {
    console.log(`   - ${name} (from ${file})`);
  });
  console.log(`\nüìÅ Output: ${outputPath}\n`);
}

// Run generator
generateTypes().catch((error) => {
  console.error('‚ùå Type generation failed:', error);
  process.exit(1);
});

