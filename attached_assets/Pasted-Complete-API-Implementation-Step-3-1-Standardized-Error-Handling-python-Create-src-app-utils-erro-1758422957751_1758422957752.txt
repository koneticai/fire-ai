Complete API Implementation

Step 3.1: Standardized Error Handling
python# Create src/app/utils/errors.py
from fastapi import HTTPException, Request
from fastapi.responses import JSONResponse
import uuid
from typing import Dict, Any

ERROR_REGISTRY = {
    400: ("FIRE-400", "Bad Request: General validation error", False),
    401: ("FIRE-401", "Unauthorized: Invalid or expired JWT", False),
    403: ("FIRE-403", "Forbidden: Insufficient permissions", False),
    404: ("FIRE-404", "Not Found: Resource does not exist", True),
    409: ("FIRE-409", "Conflict: CRDT merge conflict or idempotency key reuse", False),
    422: ("FIRE-422", "Unprocessable Entity: Semantic validation error", False),
    429: ("FIRE-429", "Too Many Requests: Rate limit exceeded", True),
    500: ("FIRE-500", "Internal Server Error: Generic server failure", True),
    503: ("FIRE-503", "Service Unavailable: Downstream dependency failure", True),
}

async def error_handler(request: Request, exc: HTTPException):
    error_code, message, retryable = ERROR_REGISTRY.get(
        exc.status_code, 
        ("FIRE-500", "Internal Server Error", True)
    )
    
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "transaction_id": str(uuid.uuid4()),
            "error_code": error_code,
            "message": exc.detail or message,
            "retryable": retryable
        }
    )
Step 3.2: Complete Test Sessions API
python# Update src/app/routers/test_sessions.py
from fastapi import APIRouter, Depends, Query, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_
from typing import Optional, List, Dict
import base64
import json
from ..database.core import get_db
from ..models.test_sessions import TestSession
from ..dependencies import get_current_active_user
from ..schemas.auth import TokenPayload

router = APIRouter(prefix="/v1/tests/sessions", tags=["test_sessions"])

@router.get("/")
async def list_test_sessions(
    limit: int = Query(20, ge=1, le=100),
    cursor: Optional[str] = None,
    status: Optional[List[str]] = Query(None),
    date_from: Optional[str] = None,
    date_to: Optional[str] = None,
    technician_id: Optional[str] = None,
    db: AsyncSession = Depends(get_db),
    current_user: TokenPayload = Depends(get_current_active_user)
):
    # Decode cursor
    cursor_data = {}
    if cursor:
        try:
            cursor_data = json.loads(base64.b64decode(cursor))
        except:
            raise HTTPException(status_code=400, detail="Invalid cursor")
    
    # Build query
    query = select(TestSession)
    conditions = []
    
    if status:
        conditions.append(TestSession.status.in_(status))
    if date_from:
        conditions.append(TestSession.created_at >= date_from)
    if date_to:
        conditions.append(TestSession.created_at <= date_to)
    if cursor_data.get("last_evaluated_id"):
        conditions.append(TestSession.id > cursor_data["last_evaluated_id"])
    
    if conditions:
        query = query.where(and_(*conditions))
    
    query = query.order_by(TestSession.created_at).limit(limit + 1)
    
    result = await db.execute(query)
    sessions = result.scalars().all()
    
    # Generate next cursor
    next_cursor = None
    if len(sessions) > limit:
        sessions = sessions[:limit]
        last_session = sessions[-1]
        cursor_data = {
            "last_evaluated_id": str(last_session.id),
            "vector_clock": last_session.vector_clock or {}
        }
        next_cursor = base64.b64encode(json.dumps(cursor_data).encode()).decode()
    
    return {
        "data": [
            {
                "session_id": str(s.id),
                "building_id": str(s.building_id),
                "status": s.status,
                "created_at": s.created_at.isoformat()
            } for s in sessions
        ],
        "next_cursor": next_cursor
    }

@router.get("/{session_id}/offline_bundle")
async def get_offline_bundle(
    session_id: str,
    db: AsyncSession = Depends(get_db),
    current_user: TokenPayload = Depends(get_current_active_user)
):
    result = await db.execute(
        select(TestSession).where(TestSession.id == session_id)
    )
    session = result.scalar_one_or_none()
    
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    
    # Generate offline bundle
    bundle = {
        "session_id": str(session.id),
        "timestamp": datetime.utcnow().isoformat(),
        "data": {
            "building": {},  # Fetch from building_id
            "assets": [],     # Fetch related assets
            "prior_faults": []  # Fetch historical faults
        }
    }
    
    # Compress if > 50MB (TDD requirement)
    import gzip
    compressed = gzip.compress(json.dumps(bundle).encode())
    if len(compressed) > 50 * 1024 * 1024:
        raise HTTPException(status_code=413, detail="Bundle too large")
    
    return bundle
Step 3.3: Evidence API with Go Service Integration
python# Create src/app/routers/evidence.py
from fastapi import APIRouter, Depends, UploadFile, Form, HTTPException
from ..proxy import proxy_to_go
from ..dependencies import get_current_active_user

router = APIRouter(prefix="/v1", tags=["evidence"])

@router.post("/evidence")
async def upload_evidence(
    file: UploadFile,
    sha256_hash: str = Form(...),
    current_user = Depends(get_current_active_user)
):
    # Proxy to Go service for performance
    return await proxy_to_go(
        method="POST",
        path="/v1/evidence",
        files={"file": file},
        data={"sha256_hash": sha256_hash},
        user_id=str(current_user.user_id)
    )
Step 3.4: Update Main Application
python# Update src/app/main.py
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from .routers import buildings, test_sessions, evidence
from .utils.errors import error_handler

app = FastAPI(title="FireMode Compliance Platform", version="2.0.0")

# Error handling
app.add_exception_handler(HTTPException, error_handler)

# Routers
app.include_router(buildings.router)
app.include_router(test_sessions.router)
app.include_router(evidence.router)

# Health check
@app.get("/health")
async def health():
    return {"status": "ok", "version": "2.0.0"}